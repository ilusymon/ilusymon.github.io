{"meta":{"title":"冬","subtitle":"","description":"","author":"symon","url":"http://ilusymon.xyz","root":"/"},"pages":[{"title":"messageboard","date":"2020-12-02T10:25:50.000Z","updated":"2020-12-02T10:25:50.898Z","comments":true,"path":"messageboard/index.html","permalink":"http://ilusymon.xyz/messageboard/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-12-02T10:23:53.000Z","updated":"2020-12-02T10:24:30.494Z","comments":true,"path":"tags/index.html","permalink":"http://ilusymon.xyz/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-12-02T10:25:08.000Z","updated":"2020-12-02T10:25:33.822Z","comments":true,"path":"categories/index.html","permalink":"http://ilusymon.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"git","slug":"git","date":"2020-12-02T00:42:17.000Z","updated":"2020-12-02T00:42:17.412Z","comments":true,"path":"2020/12/02/git/","link":"","permalink":"http://ilusymon.xyz/2020/12/02/git/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Docker入门","slug":"Docker入门","date":"2020-12-01T03:27:54.000Z","updated":"2020-12-03T09:22:49.958Z","comments":true,"path":"2020/12/01/Docker入门/","link":"","permalink":"http://ilusymon.xyz/2020/12/01/Docker%E5%85%A5%E9%97%A8/","excerpt":"掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库","text":"掌握Docker基础知识，能够理解Docker镜像与容器的概念 完成Docker安装与启动 掌握Docker镜像与容器相关命令 掌握Tomcat Nginx 等软件的常用应用的安装 掌握docker迁移与备份相关命令 能够运用Dockerfile编写创建容器的脚本 能够搭建与使用docker私有仓库 1 Docker简介1.1 什么是虚拟化虚拟化，是指通过虚拟化技术将一台计算机虚拟为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在相互独立的空间内运行而互不影响，从而显著提高计算机的工作效率。 虚拟化技术种类很多，例如：软件虚拟化、硬件虚拟化、内存虚拟化、网络虚拟化(vip)、桌面虚拟化、服务虚拟化、虚拟机等等。 1.2 问题：为什么会有docker出现？一款产品从开发到上线，从操作系统，到运行环境，再到应用配置。作为开发+运维之间的协作我们需要关心很多东西，这也是很多互联网公司都不得不面对的问题，特别是各种版本的迭代之后，不同版本环境的兼容，对运维人员都是考验 , 这个时候 Docker 横空出世，是因为它对此给出了一个标准化的解决方案。 环境配置如此麻烦，换一台机器，就要重来一次，费力费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。开发人员利用 Docker 可以消除协作编码时“在我的机器上可正常工作”的问题。 之前，可以发现，每发布一个程序，都要走一遍以上的流程： 1.2 什么是Docker Docker 是一个开源的应用容器引擎，基于 Go 语言开发。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 Docker的主要目标是“Build，Ship and Run Any App,Anywhere”，也就是通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的APP（可以是一个WEB应用或数据库应用等等）及其运行环境能够做到“一次封装，到处运行”。 总之一句话：只需要一次配置好环境，换到别的机子上就可以一键部署好，大大简化了操作 。 为什么选择Docker? Docker的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现“这段代码在我机器上没问题啊”这类问题；——一致的运行环境 可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间 避免公用的服务器，资源会容易受到其他用户的影响。——隔离性 善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展 可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便 使用Docker可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署 Docker应用场景 ① Web 应用的自动化打包和发布② 自动化测试和持续集成、发布③ 在服务型环境中部署和调整数据库或其他的后台应用 使用Docker可以实现开发人员的开发环境、测试人员的测试环境、运维人员的生产环境的一致性。 Docker借鉴了标准集装箱的概念。标准集装箱将货物运往世界各地，Docker将这个模型运用到自己的设计中，唯一不同的是：集装箱运输货物，而Docker运输软件。 1.3 容器与虚拟机比较 下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。 传统虚拟机 传统虚拟机技术基于安装在主操作系统上的虚拟机管理系统（如：VirtualBox和VMWare等），创建虚拟机（虚拟出各种硬件），在虚拟机上安装从操作系统，在从操作系统中安装部署各种应用。 Docker Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker优势体现为启动速度快、占用体积小。 使用上的区别 简单来说： 容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。 1.4 Docker 组件1.4.1 Docker组成部分 Docker是一个客户端-服务器（C/S）架构程序。Docker客户端只需要向Docker服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker提供了一个命令行工具Docker以及一整套RESTful API。你可以在同一台宿主机上运行Docker守护进程和客户端，也可以从本地的Docker客户端连接到运行在另一台宿主机上的远程Docker守护进程。 1.4.2 Docker镜像与容器镜像：类似虚拟机镜像 , 是一个特殊的文件系统 操作系统分为内核和用户空间。对于Linux而言，内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像（Image），就相当于是一个root文件系统。 Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 镜像不包含任何动态数据，其内容在构建之后也不会被改变。 容器：类似linux系统环境，运行和隔离应用。是镜像运行时的实体 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等 。 仓库：集中存放镜像文件的地方。 镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中存储、分发镜像的地方，比如后面我们要学的，Docker Registry就是这样的服务。 1.4.3 Registry（注册中心） Docker用Registry来保存用户构建的镜像。Registry分为公共和私有两种。Docker公司运营公共的Registry叫做Docker Hub。用户可以在Docker Hub注册账号，分享并保存自己的镜像（说明：在Docker Hub下载镜像巨慢，可以自己构建私有的Registry）。 https://hub.docker.com/ 2 Docker安装与启动2.1 安装Docker Docker官方建议在Ubuntu中安装，因为Docker是基于Ubuntu发布的，而且一般Docker出现的问题Ubuntu是最先更新或者打补丁的。在很多版本的CentOS中是不支持更新最新的一些补丁包的。 由于我们学习的环境都使用的是CentOS，因此这里我们将Docker安装到CentOS上。注意：这里建议安装在CentOS7.x以上的版本，在CentOS6.x的版本中，安装前需要安装其他很多的环境而且Docker很多补丁不支持更新。 1ip addr （1）yum 包更新到最新 1sudo yum update （2）安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 1sudo yum install -y yum-utils device-mapper-persistent-data lvm2 1234567891011121314151617181920212223242526272829303132333435363738394041424344[root@localhost ~]# sudo yum install -y yum-utils device-mapper-persistent-data lvm2上次元数据过期检查：0:09:56 前，执行于 2020年12月01日 星期二 20时10分54秒。软件包 device-mapper-persistent-data-0.8.5-3.el8.x86_64 已安装。软件包 lvm2-8:2.03.08-3.el8.x86_64 已安装。依赖关系解决。&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 软件包 架构 版本 仓库 大小&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;安装: yum-utils noarch 4.0.12-4.el8_2 BaseOS 66 k事务概要&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;安装 1 软件包总下载：66 k安装大小：20 k下载软件包：yum-utils-4.0.12-4.el8_2.noarch.rpm 119 kB&#x2F;s | 66 kB 00:00 ---------------------------------------------------------------------------------------------总计 63 kB&#x2F;s | 66 kB 00:01 警告：&#x2F;var&#x2F;cache&#x2F;dnf&#x2F;BaseOS-929b586ef1f72f69&#x2F;packages&#x2F;yum-utils-4.0.12-4.el8_2.noarch.rpm: 头V3 RSA&#x2F;SHA256 Signature, 密钥 ID 8483c65d: NOKEYCentOS-8 - Base 1.6 MB&#x2F;s | 1.6 kB 00:00 导入 GPG 公钥 0x8483C65D: Userid: &quot;CentOS (CentOS Official Signing Key) &lt;security@centos.org&gt;&quot; 指纹: 99DB 70FA E1D7 CE22 7FB6 4882 05B5 55B3 8483 C65D 来自: &#x2F;etc&#x2F;pki&#x2F;rpm-gpg&#x2F;RPM-GPG-KEY-centosofficial导入公钥成功运行事务检查事务检查成功。运行事务测试事务测试成功。运行事务 准备中 : 1&#x2F;1 安装 : yum-utils-4.0.12-4.el8_2.noarch 1&#x2F;1 运行脚本: yum-utils-4.0.12-4.el8_2.noarch 1&#x2F;1 验证 : yum-utils-4.0.12-4.el8_2.noarch 1&#x2F;1 Installed products updated.已安装: yum-utils-4.0.12-4.el8_2.noarch 完毕！ （3）设置yum源为阿里云 1sudo yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo （4）安装docker 1sudo yum install docker-ce centos8默认使用podman代替docker，所以需要containerd.io 1yum install https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;fedora&#x2F;30&#x2F;x86_64&#x2F;stable&#x2F;Packages&#x2F;containerd.io-1.2.6-3.3.fc30.x86_64.rpm 继续安装Docker （5）安装后查看docker版本 1docker -v 2.2 设置ustc的镜像ustc是老牌的linux镜像服务提供者了，还在遥远的ubuntu 5.04版本的时候就在用。ustc的docker镜像加速器速度很快。ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。 https://lug.ustc.edu.cn/wiki/mirrors/help/docker 编辑该文件： 1vi &#x2F;etc&#x2F;docker&#x2F;daemon.json 1报错&quot;&#x2F;etc&#x2F;docker&#x2F;daemon.json&quot; E212: Can&#39;t open file for writing 原因：centos8需要先启动docker服务，此时系统自动产生/etc/docker目录，此时才能生成daemon.json文件并进行编辑 1systemctl start docker 在该文件中输入如下内容： 123&#123;&quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&quot;]&#125; 2.3 Docker的启动与停止systemctl命令是系统服务管理器指令 启动docker： 1systemctl start docker 查看docker状态： 1systemctl status docker q 退出 停止docker： 1systemctl stop docker 重启docker： 1systemctl restart docker 开机启动： 1systemctl enable docker 查看docker概要信息 1docker info 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[root@localhost ~]# docker infoClient: Debug Mode: falseServer: Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 19.03.13 Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host ipvlan macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 894b81a4b802e4eb2a91d1ce216b8817763c29fb runc version: 425e105d5a03fabd737a126ad93d62a9eeede87f init version: fec3683 Security Options: seccomp Profile: default Kernel Version: 4.18.0-193.28.1.el8_2.x86_64 Operating System: CentOS Linux 8 (Core) OSType: linux Architecture: x86_64 CPUs: 4 Total Memory: 3.664GiB Name: localhost.localdomain ID: G3LC:FVAP:SHRP:DER4:7ALK:T3X6:UEBP:AKRF:DQN4:CSW6:EDFG:SUVX Docker Root Dir: &#x2F;var&#x2F;lib&#x2F;docker Debug Mode: false Registry: https:&#x2F;&#x2F;index.docker.io&#x2F;v1&#x2F; Labels: Experimental: false Insecure Registries: 127.0.0.0&#x2F;8 Registry Mirrors: https:&#x2F;&#x2F;docker.mirrors.ustc.edu.cn&#x2F; Live Restore Enabled: false 查看docker帮助文档 1docker --help 指令介绍： 1234567891011121314cp:本地文件系统(OS操作系统|宿主机)和容器之间进行文件或者文件夹拷贝exec:登录一个容器，使用命令行操作正在运行的容器。images:镜像的集合查询。ps:容器列表pull:下载镜像restart:重启一个或多个容器rm:删除一个或多个容器rmi:删除一个或多个镜像run:创建一个容器，并运行起来save:导出镜像到一个文件(tar)中search:搜索镜像（从Docker Hub）start：启动一个或多个已经停止的容器restart:重启动一个或多个已经停止的容器stop：停止一个或多个正在运行的容器 3 常用命令3.1镜像相关命令3.1.1 查看镜像12# 查看镜像可以使用如下命令：docker images REPOSITORY：镜像名称 TAG：镜像标签 IMAGE ID：镜像ID CREATED：镜像的创建日期（不是获取该镜像的日期） SIZE：镜像大小 这些镜像都是存储在Docker的 /var/lib/docker 目录下 3.1.2 搜索镜像如果你需要从网络中查找需要的镜像，可以通过以下命令搜索 123# 如果你需要从网络中查找需要的镜像，可以通过以下命令搜索docker search 镜像名称# 比如 docker search nginx 例如 搜索一个 nginx 镜像 NAME：仓库名称 DESCRIPTION：镜像描述 STARS：用户评价，反应一个镜像的受欢迎程度 OFFICIAL：是否官方 AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的 3.1.3 拉取镜像拉取镜像就是从中央仓库中下载镜像到本地 12345# 拉取镜像就是从Docker仓库下载镜像到本地，镜像名称格式为 名称:版本号，如果版本号不指定则是最新的版本 命令如下：docker pull 镜像名称# 例如，我要下载centos7镜像docker pull centos:7 刚刚下载的镜像通过 docker images 就可以查看 3.1.4 删除镜像按镜像ID删除镜像 12# 可以按照镜像id删除镜像，命令如下：docker rmi 镜像ID 删除 nginx 镜像 删除所有镜像 1docker rmi &#96;docker images -q&#96; 3.15 从Docker Hub拉取Docker镜像首页，包括官方镜像和其它公开镜像。Docker Hub上最受欢迎的10大镜像（通过Docker registry API获取不了镜像被pull的个数，只能通过镜像的stars数量，来衡量镜像的流行度。毫无疑问，拥有最高stars数量的库都是官方库）。 1https:&#x2F;&#x2F;hub.docker.com&#x2F;search?image_filter&#x3D;official&amp;type&#x3D;image 国情的原因，国内下载 Docker HUB 官方的相关镜像比较慢，可以使用国内（docker.io）的一些镜像加速器，镜像保持和官方一致，关键是速度块，推荐使用。 3.2 容器相关命令容器，也是docker中的核心概念，镜像是创建容器的软件 , 容器是由镜像运行产生的运行实例。镜像和容器的关系，就如同Java语言中类和对象的关系。 如果需要通俗的描述容器的话，我觉得容器就是一个存放东西的地方，就像书包可以装各种文具、衣柜可以放各种衣服、鞋架可以放各种鞋子一样。我们现在所说的容器存放的东西可能更偏向于应用比如网站、程序甚至是系统环境。 3.2.1 查看容器查看正在运行的容器 1docker ps 查看最后一次运行的容器 1docker ps –l l：last 查看停止的容器 1docker ps -f status&#x3D;exited 3.2.2 创建与启动容器① 什么是宿主机？ 就是主机，这个概念是相对于子机而言的，比如你安装有虚拟机的话，那么相对于虚拟机而言，你正在使用的计算机就是宿主机，虚拟机是安装在主机上的，必须在主机上才能运行，主机就是一个“宿主”。 ② 创建容器常用的参数说明： 创建容器命令：docker run 1234567891011-i：表示运行容器-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。--name :为创建的容器命名。-v：表示目录映射关系（前者是宿主机目录，后者是映射到容器上的目录），可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加-i -t两个参数，创建后就会自动进去容器）。-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个-p做多个端口映射 （1）交互式方式创建容器 以交互式方式创建并启动容器，启动完成后，直接进入当前容器。使用exit命令退出容器。需要注意的是以此种方式启动容器，如果退出容器，则容器会进入停止状态。可以理解成交互式容器 是前台容器。 12345678910111213docker run -it --name&#x3D;容器名称 镜像名称:标签 &#x2F;bin&#x2F;bash# 比如：docker run -it --name&#x3D;mycentos centos:7 &#x2F;bin&#x2F;bash# docker run:表示创建容器# -it：表示运行容器并进入它的命令行# --name&#x3D;mycentos：给当前的容器命名# centos:7：使用该镜像创建# &#x2F;bin&#x2F;bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 &#x2F;bin&#x2F;bash 准备镜像 创建容器 1docker run -it --name&#x3D;mycentos centos:latest 创建好容器，并且已经进入到容器内部了，可以直接观察前面中括号里面的内容发现，跟创建容器之前不一样了， 并且 通过 dir 命令，会发现，其实容器内部也是一个 centos , 我们可以把每个容器都看成一个小电脑或者服务器 重新开一个新的会话，查看刚刚创建的容器是否已经有了。 12# 查看正在运行的容器docker ps 退出当前容器 1exit 退出之后，容器也退出了，没有删除 （3）守护式方式创建容器： 创建一个守护式容器；如果对于一个需要长期运行的容器来说，我们可以创建一个守护式容器。命令如下（容器名称不能重复）：守护容器可以理解成在后台运行的容器 12345# 守护式容器和交互式容器的创建方式区别：# ① -it 换成 -di# ② 去掉后面的 &#x2F;bin&#x2F;bashdocker run -di --name&#x3D;容器名称 镜像名称:标签# 比如：docker run -di --name&#x3D;mycentos10 centos:latest 进入守护式容器方式： 12docker exec -it 容器名称 (或者容器ID) &#x2F;bin&#x2F;bash# 比如 docker exec -it mycentos10 &#x2F;bin&#x2F;bash 已经进入到容器内部了，如果现在退出，然后查看容器是否还在后台运行 守护容器不会主动退出 3.2.3 停止与启动容器停止容器： 12docker stop 容器名称（或者容器ID）例如： docker stop mycentos10 查看容器是否已经停止 启动容器： 12docker start 容器名称（或者容器ID）例如： docker start mycentos10 3.2.4 文件拷贝我们需要在容器内安装一个软件，软件首先需要有安装包，我们就需要把安装包拷贝到容器内。我们通常的操作是先把文件上传到宿主机，然后我们在将文件从宿主机拷贝到容器内的某个目录下面进行安装。 如果我们需要将文件拷贝到容器内可以使用cp命令 12docker cp 需要拷贝的文件或目录 容器名称:容器目录例如： docker cp anaconda-ks.cfg mycentos10:&#x2F;usr&#x2F;local&#x2F; 拷贝一个文件到 mycentos10 的/urs/local/ 文件下面 ，拷贝完成之后，删除文件，然后在mycentos10`拷贝过来 登录容器查看拷贝之后的结果 1234docker exec -it mycentos10 &#x2F;bin&#x2F;bashdocker exec：表示登陆正在运行的容器-it：进入命令行mycentos10：进入到该容器 也可以将文件从容器内拷贝出来 12docker cp 容器名称:容器目录 需要拷贝的文件或目录例如：docker cp mycentos10:&#x2F;usr&#x2F;local&#x2F;anaconda-ks.cfg ~ 我们先通过 exit 退出容器，然后在把文件从容器拷贝到当前目录 3.2.5 目录挂载我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。 创建容器 添加-v参数 后边为 宿主机目录:容器目录，例如： 1234# 创建并启动容器mycentos3,并挂载linux中的&#x2F;usr&#x2F;local&#x2F;myhtml目录到容器的&#x2F;usr&#x2F;local&#x2F;myhtml；也就是在linux中的&#x2F;usr&#x2F;local&#x2F;myhtml中操作相当于对容器相应目录操作docker run -di --name&#x3D;容器的名字 -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml --name&#x3D;mycentos3 centos:7比如：docker run -di --name&#x3D;mycentos3 -v &#x2F;usr&#x2F;local&#x2F;myhtml:&#x2F;usr&#x2F;local&#x2F;myhtml centos:latest 通过 docker ps 查看刚刚创建的容器是否已经创建 进入到 myhtml 目录 ，通过dir查看是否有文件，通过vi test2 ，创建一个文件，进入test2文件，随便输入一些数据 进入目录随便输入一些东西 ， 退出保存 登录容器，查看刚刚输入的内容 123456789101112# 进入容器docker exec -it mycentos3 &#x2F;bin&#x2F;bash# 进入容器中查看目录cd &#x2F;usr&#x2F;local&#x2F;myhtml# 查看myhtml目录中，是否有对应文件testlscat test# 退出容器exit 如果你共享的是多级的目录，可能会出现权限不足的提示。 这是因为CentOS中的安全模块selinux把权限禁掉了，我们需要添加参数 –privileged=true 来解决挂载的目录没有权限的问题 3.2.6 查看容器IP地址我们可以通过以下命令查看容器运行的各种数据 123docker inspect 容器名称（容器ID） # 在linux宿主机下查看 mycentos3 的ip IP 地址 通过inspect 可以查看的信息太多，如果想单纯有针对性的查看某个信息，也可以直接执行下面的命令直接输出IP地址 12docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; 容器名称（容器ID）# 例如：docker inspect --format&#x3D;&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; mycentos3 3.2.7 删除容器删除指定的容器： 12docker rm 容器名称（容器ID）例如：docker rm mycentos11 删除容器的时候，如果容器在运行，会报错，必须先停止容器 12345678# 查看正在运行的容器docker ps# 停止容器docker stop mycentos10# 删除容器docker rm mycentos10 4 应用部署4.1 MySQL部署 （1）拉取mysql镜像 1docker pull centos&#x2F;mysql-57-centos7 （2）创建容器 1234# 创建mysql5.7容器# docker run -di --name&#x3D;容器名字 -p 宿主机端口:容器端口 -e MYSQL_ROOT_PASSWORD&#x3D;mysql密码 容器名称docker run -di --name&#x3D;mysql5.7 -p 33306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 centos&#x2F;mysql-57-centos7 （3）远程登录mysql 连接宿主机的IP ,指定端口为33306 4.2 tomcat部署（1）拉取镜像 1docker pull tomcat:7-jre7 tomcat9 有待解决bug （2）创建容器 创建容器 -p表示地址映射 -v 表示目录挂载 12# 创建tomcat容器;并挂载了webapps目录docker run -di --name&#x3D;mytomcat -p 9000:8080 -v &#x2F;usr&#x2F;local&#x2F;webapps:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps tomcat:7-jre7 本地的war包 ，上传到docker容器里面 ls 查看 dubbo的war 是否已经上传到docker容器，上传成功之后，请求 http://192.168.43.129:9000/dubbo-admin-2.6.0/ 4.3 Nginx部署（1）拉取镜像 1docker pull nginx （2）创建Nginx容器 1docker run -di --name&#x3D;mynginx -p 80:80 nginx 安装完成之后，请求nginx页面 4.4 Redis部署（1）拉取镜像 1docker pull redis （2）创建容器 1docker run -di --name&#x3D;myredis -p 6379:6379 redis 5 迁移与备份 其中涉及到的命令有： docker commit 将容器保存为镜像 docker save 将镜像备份为tar文件 docker load 根据tar文件恢复为镜像 5.1 容器保存为镜像我们可以通过以下命令将容器保存为镜像 123# 保存nginx容器为镜像docker commit 容器名称 镜像名称例如：docker commit mynginx mynginx_i 使用 docker ps -a 查看所有的容器 看到有一个mynginx 容器 , 将容器保存为一个镜像： 查看镜像是否保存成功 使用刚刚保存的镜像 ，重新创建一个容器 1docker run -di --name&#x3D;mynginx2 -p 81:80 mynginx_i 通过 docker ps查看正在运行的容器，可以找到刚刚创建的容器mynginx2 5.2 镜像备份我们可以通过以下命令将镜像保存为tar 文件 123# 命令形式：docker save –o tar文件名 镜像名# 保存镜像为文件 -o：表示output 输出的意思docker save -o mynginx.tar mynginx_i 通过 save 保存成文件之后，在通过 ls 命令进行查看当前目录是否有 tar文件 5.3 镜像恢复与迁移首先我们先删除掉mynginx_img镜像 然后执行此命令进行恢复 直接删除 mynginx_i 镜像 ，发现会报错，因为当前镜像的容器正在运行，需要先停止容器，删除容器 ， 在删除镜像 1docker stop mynginx2 1docker rm mynginx2 1docker rmi mynginx_i mynginx_i 镜像已经被删除 恢复镜像 12# 命令形式：docker load -i tar文件名docker load -i mynginx.tar 6 Dockerfile6.1 什么是Dockerfile要获得镜像，可以从Docker仓库中进行下载。那如果我们想自己开发一个镜像，那该如何做呢？答案是：DockerfileDockerfile其实就是一个文本文件，由一系列命令和参数构成，Docker可以读取Dockerfile文件并根据Dockerfile文件的描述来构建镜像。 1、对于开发人员：可以为开发团队提供一个完全一致的开发环境；2、对于测试人员：可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作了；3、对于运维人员：在部署时，可以实现应用的无缝移植。 6.2 常用命令 命令 作用 FROM image_name:tag 定义了使用哪个基础镜像启动构建流程 MAINTAINER user_name 声明镜像的创建者 ENV key value 设置环境变量 (可以写多条) RUN command 是Dockerfile的核心部分(可以写多条) ADD source_dir/file dest_dir/file 将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压 COPY source_dir/file dest_dir/file 和ADD相似，但是如果有压缩文件并不能解压 WORKDIR path_dir 设置工作目录 6.3 使用脚本创建镜像步骤： （1）创建目录 1mkdir –p &#x2F;usr&#x2F;local&#x2F;dockerjdk8 （2）下载jdk-8u144-linux-x64.tar.gz并上传到服务器（虚拟机）中的/usr/local/dockerjdk8目录 （3）创建文件Dockerfile vim Dockerfile 12# Dockerfile 名字不要改vim Dockerfile 123456789101112131415#依赖镜像名称和IDFROM centos:latest#指定镜像创建者信息MAINTAINER ilusymon#切换工作目录WORKDIR &#x2F;usrRUN mkdir &#x2F;usr&#x2F;local&#x2F;java#ADD 是相对路径jar,把java添加到容器中ADD jdk-8u144-linux-x64.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;#配置java环境变量ENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_144ENV JRE_HOME $JAVA_HOME&#x2F;jreENV CLASSPATH $JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib:$CLASSPATHENV PATH $JAVA_HOME&#x2F;bin:$PATH （4）执行命令构建镜像 1docker build -t&#x3D;&#39;jdk1.8&#39; . 注意后边的空格和点，不要省略 1docker images 7 Docker私有仓库（1）拉取私有仓库镜像 1docker pull registry （2）启动私有仓库容器 1docker run -di --name&#x3D;registry -p 5000:5000 registry （3）打开浏览器 输入地址 http://192.168.43.129:5000/v2/_catalog 看到&#123;&quot;repositories&quot;:[]&#125; 表示私有仓库搭建成功并且内容为空 （4）修改daemon.json 1vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 添加以下内容，保存退出。目的是让容器信任下面的地址 1&quot;insecure-registries&quot;:[&quot;192.168.43.129:5000&quot;] 此步用于让 docker信任私有仓库地址 ，然后退出保存 （5）重启docker 服务 1systemctl restart docker 7.2 镜像上传至私有仓库（1）标记此镜像为私有仓库的镜像 123# 1、标记镜像为私有仓库的镜像 # docker tag jdk1.8 宿主机IP:5000&#x2F;jdk1.8docker tag jdk1.8 192.168.43.129:5000&#x2F;jdk1.8 （2）再次启动私服容器 12# 2、再次启动私有仓库容器 docker start registry （3）上传标记的镜像 123# 3、上传标记的镜像 # docker push 宿主机IP:5000&#x2F;jdk1.8docker push 192.168.43.129:5000&#x2F;jdk1.8 重新刷新，发现jdk 1.8 已经上传到私服 7.3 从私有仓库拉取镜像7.3.1 其它服务器拉取私有仓库镜像大多数情况下，都是某台服务器部署了私有镜像仓库之后；到其它服务器上从私有仓库中拉取镜像，若要拉取私有仓库镜像需要去修改docker的配置文件，设置启动时候的仓库地址。 1234567# 打开配置文件vim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service# 在打开的上述文件中按照下面的图，添加如下的内容；注意修改下面内容中的ip地址--add-registry&#x3D;192.168.43.129:5000&#x2F; --insecure-registry&#x3D;192.168.43.129:5000 \\# 修改完后需要重新加载docker配置文件并重启dockersystemctl daemon-reloadsystemctl restart docker 配置完成之后，需要重启 docker 和修改 配置文件 1systemctl daemon-reload 1systemctl restart docker 在重启之后；就可以去拉取私有仓库中的镜像： 123# 执行拉取镜像命令并查看docker pull 192.168.43.129:5000&#x2F;jdk1.8docker images","categories":[],"tags":[{"name":"容器","slug":"容器","permalink":"http://ilusymon.xyz/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"Tem","slug":"Tem","date":"2020-12-01T02:46:41.000Z","updated":"2020-12-01T02:46:41.527Z","comments":true,"path":"2020/12/01/Tem/","link":"","permalink":"http://ilusymon.xyz/2020/12/01/Tem/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"linux汉化man命令","slug":"linux汉化man命令","date":"2020-12-01T02:46:41.000Z","updated":"2020-12-01T02:52:01.076Z","comments":true,"path":"2020/12/01/linux汉化man命令/","link":"","permalink":"http://ilusymon.xyz/2020/12/01/linux%E6%B1%89%E5%8C%96man%E5%91%BD%E4%BB%A4/","excerpt":"1.下载源码源码网址 https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/ 下载源码 wget https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/v1.5.2.tar.gz/1bbdc4f32272df0b95146518b27bf4be/v1.5.2.tar.gz [root@localhost opt]# wget https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/manpages-zh-1.5.1.tar.gz/13275fd039de8788b15151c896150bc4/manpages-zh-1.5.1.tar.gz","text":"1.下载源码源码网址 https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/ 下载源码 wget https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/v1.5.2.tar.gz/1bbdc4f32272df0b95146518b27bf4be/v1.5.2.tar.gz [root@localhost opt]# wget https://src.fedoraproject.org/repo/pkgs/man-pages-zh-CN/manpages-zh-1.5.1.tar.gz/13275fd039de8788b15151c896150bc4/manpages-zh-1.5.1.tar.gz 2.解压并安装[root@localhost opt]# tar xf manpages-zh-1.5.1.tar.gz [root@localhost opt]# cd manpages-zh-1.5.2/ [root@localhost manpages-zh-1.5.1]# ./configure –disable-zhtw –prefix=/usr/local/zhman [root@localhost manpages-zh-1.5.1]# make &amp;&amp; make install 3、为了不抵消man，我们新建cman命令作为中文查询[root@localhost man1]# cd ~ [root@localhost ~]# echo “alias cman=’man -M /usr/local/zhman/share/man/zh_CN’ “ &gt;&gt;.bash_profile[root@localhost ~]# source .bash_profile 4.使用中文man查询命令[root@localhost ~]# cman ls","categories":[],"tags":[]},{"title":"Ajax与Json","slug":"Ajax与Json","date":"2020-11-30T00:45:42.000Z","updated":"2020-11-30T00:48:11.814Z","comments":true,"path":"2020/11/30/Ajax与Json/","link":"","permalink":"http://ilusymon.xyz/2020/11/30/Ajax%E4%B8%8EJson/","excerpt":"第1章 AJAX简介","text":"第1章 AJAX简介 1.1 什么是AJAX? AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。异步 同步(请求和响应都是同步的) AJAX的实际意义是，不发生页面跳转、异步请求载入内容并改写局部页面内容的技术。局部刷新(js完成) AJAX也可以简单的理解为通过JS向服务器发送请求。 (location.href=””:是js给浏览器设置路径，请求时浏览器发出的，响应也是响应给浏览器) JS往服务器发送请求：是js这个语言去访问服务器，如果服务器给响应，响应给js AJAX这门技术很早就被发明，但是直到2005年被谷歌的大量使用，才在市场中流行起来，可以说Google为AJAX的推广起到到推波助澜的作用。 同步处理与异步处理 同步处理： AJAX出现之前，我们访问互联网时一般都是同步请求，也就是当我们通过一个页面向服务器发送一个请求时，在服务器响应结束之前，我们的整个页面是不能操作的，也就是直观上来看他是卡主不动的。 这就带来了非常糟糕的用户体验。首先，同步请求时，用户只能等待服务器的响应，而不能做任何操作。其次，如果请求时间过长可能会给用户一个卡死的感觉。最后，同步请求的最大缺点就是即使整个页面中只有一小部分内容发生改变我们也要刷新整个页面。 异步处理： 而异步处理指的是我们在浏览网页的同时，通过AJAX向服务器发送请求，发送请求的过程中我们浏览网页的行为并不会收到任何影响，甚至主观上感知不到在向服务器发送请求。当服务器正常响应请求后，响应信息会直接发送到AJAX中，AJAX可以根据服务器响应的内容做一些操作。 使用AJAX的异步请求基本上完美的解决了同步请求带来的问题。首先，发送请求时不会影响到用户的正常访问。其次，即使请求时间过长，用户不会有任何感知。最后，AJAX可以根据服务器的响应信息局部的修改页面，而不需要整个页面刷新。 1.2 AJAX的常用API1.2.1 请求对象 向服务器发送请求，毫无疑问需要使用Http协议，也就是我们需要通过JS来向服务器发送一个请求报文。这里我们来回顾一下请求报文的格式： 请求首行 请求头 空行 请求体 这是一个请求报文的格式，那我们如果手动的创建这么一个报文格式来发送给服务器想必是非常麻烦呢，于是浏览器为我们提供了一个XMLHttpRequest对象。 1.2.2 XMLHttpRequest JavaScript完成异步请求需要用到的 jQuery如何去完成异步 XMLHttpRequest对象是AJAX中非常重要的对象，所有的AJAX操作都是基于该对象的。 XMLHttpRequest对象用来封装请求报文，我们向服务器发送的请求信息全部都需要封装到该对象中。 这里需要稍微注意一下，XMLHttpRequest对象并没有成为标准，但是现在的主流浏览器都支持该对象，而一些如IE6的老版本浏览器中的创建方式有一些区别，但是问题不大。 获取XMLHttpRequest对象：由于浏览器之间的差异，不同浏览器中获取XMLHttpRequest的方式不同，但总的来说一共有三种方式： 方式一：var xhr = new XMLHttpRequest()：目前主流浏览器都支持 方式二：var xhr = new ActiveXObject(“Msxml2.XMLHTTP”)：IE6支持的方式 方式三：var xhr = new ActiveXObject(“Microsoft.XMLHTTP”)：IE5.5以下支持的方式 根据三种不同的方式编写通用方法来获取XMLHttpRequest对象： 123456789101112131415161718//获取XMLHttpRequest的通用方法function getXMLHttpRequest()&#123; var xhr; try&#123; //大部分浏览器都支持 xhr = new XMLHttpRequest(); &#125;catch(e)&#123; try&#123; //如果不支持，在这里捕获异常并且采用IE6支持的方式 xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125;catch(e)&#123; //如果还不支持，在这里捕获异常并采用IE5支持的方式 xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; &#125; return xhr;&#125; XMLHttpRequest对象的方法： **open(method,url,async)**：用于设置请求的基本信息，接收三个参数。 参数一：method 接收一个字符串，表明请求的方法：get或post 参数二：url 请求的地址，接收一个字符串 参数三：Assync 发送的请求是否为异步请求，接收一个布尔值。① true 是异步请求 ② false 不是异步请求（同步请求） send(string)：用于将请求发送给服务器，可以接收一个参数 string参数 该参数只在发送post请求时需要。用于设置请求体 **setRequestHeader(header,value)**：用于设置请求头 参数一：header参数 字符串类型，要设置的请求头的名字 参数二：value参数 字符串类型，要设置的请求头的值 XMLHttpRequest对象的属性： readyState 描述XMLHttpRequest的状态 一共有五种状态分别对应了五个数字： 0 ：请求尚未初始化，open()尚未被调用 1 ：服务器连接已建立，send()尚未被调用 2 ：请求已接收，服务器尚未响应 3 ：请求已处理，正在接收服务器发送的响应 4 ：请求已处理完毕，且响应已就绪。 status 请求的响应码 200 响应成功 404 页面为找到 500 服务器内部错误 … … … … onreadystatechange 该属性需要指向一个函数 该函数会在readyState属性发生改变时被调用 responseText 获得字符串形式的响应数据。 responseXML（用的比较少） 获得 XML 形式的响应数据。 示例代码 使用AJAX发送GET请求 1234567891011121314151617181920//获取xhr对象var xhr = getXMLHttpRequest();//设置请求信息xhr.open(&quot;get&quot;,&quot;AjaxServlet?&amp;t=&quot;+Math.random(),true);//发送请求xhr.send();//监听请求状态xhr.onreadystatechange = function()&#123;//当响应完成 if(xhr.readyState == 4)&#123; //且状态码为200时 if(xhr.status == 200)&#123; //接收响应信息（文本形式） var text = xhr.responseText; //弹出消息 alert(text); &#125; &#125;;&#125;; 这是一个最简单的AJAX代码，向AjaxServlet发送了一个get请求，并且在页面中输出响应的内容。 使用AJAX发送POST请求 123456789101112131415161718192021//获取xhr对象var xhr = getXMLHttpRequest();//设置请求信息xhr.open(&quot;post&quot;,&quot;2.jsp&quot;,true);//设置请求头xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded&quot;);//发送请求xhr.send(&quot;hello=123456&quot;);//监听请求状态xhr.onreadystatechange = function()&#123;//当响应完成if(xhr.readyState == 4)&#123; //且状态码为200时 if(xhr.status == 200)&#123; //接收响应信息（文本形式） var text = xhr.responseText; //弹出消息 alert(text); &#125;&#125;; 第2章 javaScript原生Ajax请求 原生的Ajax请求，包括如下的步骤： 我们首先要创建XMLHttpRequest 对象 调用open方法设置请求参数 调用send方法发送请求 在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 具体操作： 创建一个html页面，发起请求。代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function ajaxRequest() &#123;// 1、我们首先要创建XMLHttpRequest var xhr = new XMLHttpRequest();// 2、调用open方法设置请求参数 xhr.open(&quot;GET&quot;,&quot;ajaxServlet?action=javaScriptAjax&amp;a=&quot;+new Date(),true);// 4、在send方法前绑定onreadystatechange事件，处理请求完成后的操作。 xhr.onreadystatechange = function() &#123;//回调函数:接收服务器的响应的 // 判断请求完成，并且成功 if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; document.getElementById(&quot;div01&quot;).innerHTML = xhr.responseText; &#125; &#125;// 3、调用send方法发送请求 xhr.send(); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button onclick=&quot;ajaxRequest()&quot;&gt;ajax request&lt;/button&gt; &lt;div id=&quot;div01&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 创建一个AjaxServlet程序接收请求 1234567891011121314151617181920212223242526package com.atguigu.servlet;import java.io.IOException;import java.util.Random;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.atguigu.gson.GsonTest;import com.google.gson.Gson;public class AjaxServlet extends BaseServlet &#123; private static final long serialVersionUID = 1L; protected void javaScriptAjax(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;ajax请求过来了 a--&quot; + request.getParameter(&quot;a&quot;)); Random random = new Random(System.currentTimeMillis()); // 使用随机数，可以让客户端看到变化 response.getWriter().write( new Gson().toJson(new GsonTest.Person(random.nextInt(100), &quot;12312&quot;))); &#125;&#125; 在web.xml文件中的配置 123456789&lt;servlet&gt; &lt;servlet-name&gt;AjaxServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.atguigu.servlet.AjaxServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;AjaxServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/ajaxServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 测试效果 通过上面的代码我们发现。编写原生的JavaScript我们自己要写很多的代码。而且还要考虑浏览器兼容问题。所以使用起来非常的不方便。那我们工作之后。怎么处理Ajax请求呢。我们一般会使用JavaScript的框架来解决这个问题，比如说我们前面学到的Jquery框架。它就有很好的Ajax解决方案。 第3章 JQuery的Ajax请求 四个Ajax请求方法 $.ajax方法 $.get方法 $.post方法 $.getJSON方法 一个表单序列化方法：serialize()表单序列化方法 如何使用上面的五个方法：在JQuery中和Ajax请求有关的方法有四个 方法一： $.ajax请求参数 ​ url： 请求的地址 ​ type : 请求的方式 get或post ​ data : 请求的参数 string或json ​ success: 成功的回调函数 ​ dataType: 返回的数据类型 常用json或text 下面的方法必须遵守参数的顺序 方法二、三：$.get请求和$.post请求 ​ url:请求的URL地址 ​ data:待发送 Key/value 参数。 ​ callback:载入成功时回调函数。 ​ type:返回内容格式，xml, html, script, json, text。 方法四：Jquery的$.getJSON ​ url:待载入页面的URL地址 ​ data:待发送 Key/value 参数。 ​ callback:载入成功时回调函数。 表单的序列化 serialize() 方法可以把一个form表单中所有的表单项。都以字符串name=value&amp;name=value的形式进行拼接，省去我们很多不必要的工作。 由于$.get、$.post和getJSON这三个方法的底层都是直接或者间接地使用$.ajax()方法来实现的异步请求的调用。所以我们以$.ajax()方法的使用为示例进行展示： Jquery_Ajax_request.html的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;pragma&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot; /&gt; &lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script/jquery-1.7.2.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function()&#123; // ajax请求 $(&quot;#ajaxBtn&quot;).click(function()&#123; $.ajax(&#123; url : &quot;ajaxServlet&quot;, // 请求地址 error:function()&#123; // 请求失败回调 alert(&quot;请求失败&quot;); &#125;, success:function(data)&#123; // 请求成功回调 alert( data ); &#125;, type:&quot;POST&quot;, // 请求的方式 dataType:&quot;json&quot;, // 返回的数据类型为json对象 data:&#123; // 请求的参数 action:&quot;jqueryAjax&quot;, a:12, date: new Date() &#125; &#125;); &#125;); // ajax--get请求 $(&quot;#getBtn&quot;).click(function()&#123; $.get( &quot;ajaxServlet&quot;,&#123; action:&quot;jqueryGet&quot;, a:12, date:new Date() &#125;,function(data)&#123;alert(data);&#125;,&quot;json&quot; ); &#125;); // ajax--post请求 $(&quot;#postBtn&quot;).click(function()&#123; // post请求 $.post( &quot;ajaxServlet&quot;, // 请求路径 &#123; // 请求参数 action:&quot;jqueryPost&quot;, a:12, date:new Date() &#125;, function(data)&#123; alert( data ) &#125;, // 成功的回调函数 &quot;text&quot; // 返回的数据类型 ); &#125;); // ajax--getJson请求 $(&quot;#getJsonBtn&quot;).click(function()&#123; // 调用 $.getJSON( &quot;ajaxServlet&quot;, // 请求路径 &#123; // 请求参数 action:&quot;jqueryGetJSON&quot;, a:12, date:new Date() &#125;, function(data)&#123; alert( data ) &#125; // 成功的回调函数 ); &#125;); // ajax请求 $(&quot;#submit&quot;).click(function()&#123; // 把参数序列化 var data = $(&quot;#form01&quot;).serialize(); alert(data); &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;button id=&quot;ajaxBtn&quot;&gt;$.ajax请求&lt;/button&gt; &lt;button id=&quot;getBtn&quot;&gt;$.get请求&lt;/button&gt; &lt;button id=&quot;postBtn&quot;&gt;$.post请求&lt;/button&gt; &lt;button id=&quot;getJsonBtn&quot;&gt;$.getJSON请求&lt;/button&gt; &lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;form id=&quot;form01&quot; &gt; 用户名：&lt;input name=&quot;username&quot; type=&quot;text&quot; /&gt;&lt;br/&gt; 密码：&lt;input name=&quot;password&quot; type=&quot;password&quot; /&gt;&lt;br/&gt; 下拉单选：&lt;select name=&quot;single&quot;&gt; &lt;option value=&quot;Single&quot;&gt;Single&lt;/option&gt; &lt;option value=&quot;Single2&quot;&gt;Single2&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 下拉多选： &lt;select name=&quot;multiple&quot; multiple=&quot;multiple&quot;&gt; &lt;option selected=&quot;selected&quot; value=&quot;Multiple&quot;&gt;Multiple&lt;/option&gt; &lt;option value=&quot;Multiple2&quot;&gt;Multiple2&lt;/option&gt; &lt;option selected=&quot;selected&quot; value=&quot;Multiple3&quot;&gt;Multiple3&lt;/option&gt; &lt;/select&gt;&lt;br/&gt; 复选： &lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check1&quot;/&gt; check1 &lt;input type=&quot;checkbox&quot; name=&quot;check&quot; value=&quot;check2&quot; checked=&quot;checked&quot;/&gt; check2&lt;br/&gt; 单选： &lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;radio1&quot; checked=&quot;checked&quot;/&gt; radio1 &lt;input type=&quot;radio&quot; name=&quot;radio&quot; value=&quot;radio2&quot;/&gt; radio2&lt;br/&gt; &lt;input id=&quot;submit&quot; type=&quot;submit&quot; /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; AjaxServlet的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.atguigu.servlet;import java.io.IOException;import java.util.Random;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.atguigu.gson.GsonTest;import com.google.gson.Gson;public class AjaxServlet extends BaseServlet &#123; private static final long serialVersionUID = 1L; protected void javaScriptAjax(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;ajax请求过来了 a--&quot; + request.getParameter(&quot;a&quot;)); Random random = new Random(System.currentTimeMillis()); // 使用随机数，可以让客户端看到变化 response.getWriter().write( new Gson().toJson(new GsonTest.Person(random.nextInt(100), &quot;12312&quot;))); &#125; protected void jqueryAjax(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;jqueryAjax请求过来了 a--&quot; + request.getParameter(&quot;a&quot;)); Random random = new Random(System.currentTimeMillis()); // 使用随机数，可以让客户端看到变化 response.getWriter().write( new Gson().toJson(new GsonTest.Person(random.nextInt(100), &quot;12312&quot;))); &#125; protected void jqueryGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;jqueryGet请求过来了 a--&quot; + request.getParameter(&quot;a&quot;)); Random random = new Random(System.currentTimeMillis()); // 使用随机数，可以让客户端看到变化 response.getWriter().write( new Gson().toJson(new GsonTest.Person(random.nextInt(100), &quot;12312&quot;))); &#125; protected void jqueryPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;jqueryPost请求过来了 a--&quot; + request.getParameter(&quot;a&quot;)); Random random = new Random(System.currentTimeMillis()); // 使用随机数，可以让客户端看到变化 response.getWriter().write( new Gson().toJson(new GsonTest.Person(random.nextInt(100), &quot;12312&quot;))); &#125; protected void jqueryGetJSON(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println(&quot;jqueryGetJSON请求过来了 a--&quot; + request.getParameter(&quot;a&quot;)); Random random = new Random(System.currentTimeMillis()); // 使用随机数，可以让客户端看到变化 response.getWriter().write( new Gson().toJson(new GsonTest.Person(random.nextInt(100), &quot;12312&quot;))); &#125;&#125; 第4章 JSON简介 客户端（或浏览器）与服务器间交互时，服务器端可以返回一个字符串，但当我们需要返回一个复杂的数据时，比如说需要返回一个对象时，就需要定义一下数据的格式。 AJAX一开始使用的是XML的数据格式，XML的数据格式非常简单清晰，容易编写，但是由于XML中包含了过多的标签，以及十分复杂的结构，解析起来也相对复杂，所以目前来讲，AJAX中已经几乎不使用XML来发送数据了。取而代之的是一项新的技术JSON。 JSON是JavaScript Object Notation 的缩写，是JS提供的一种轻量级的数据交换格式， 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C，C++，C#，Java，JavaScript，Perl，Python等）。 这些特性使JSON成为理想的数据交换语言。 JSON对象本质上就是一个JS对象，但是这个对象比较特殊，它可以直接转换为字符串，在不同语言中进行传递，通过工具又可以转换为其他语言中的对象。 第5章 JSON的使用在标准的json格式中，json对象由在括号括起来，对象中的属性也就是json的key是一个字符串，所以一定要使用双引号引起来。每组key之间使用逗号进行分隔。 5.1 JSON的定义 JSON通过6种数据类型来表示： 字符串 例子：”字符串” 注意：不能使用单引号 数字： 例子：123.4 布尔值： 例子：true、false null值: 例子：null 对象 例子：{“name”:”sunwukong”, ”age”:18} 数组 例子：[1,”str”,true] 格式： 1234567var 变量名 = &#123; “key” : value , // Number类型 “key2” : “value” , // 字符串类型 “key3” : [] , // 数组类型 “key4” : &#123;&#125;, // json 对象类型 “key5” : [&#123;&#125;,&#123;&#125;] // json 数组 对象数组&#125;; 举例： 1234567891011121314151617181920212223var jsons = &#123; &quot;key1&quot;:&quot;abc&quot;, // 字符串类型 &quot;key2&quot;:1234, // Number &quot;key3&quot;:[1234,&quot;21341&quot;,&quot;53&quot;], // 数组 &quot;key4&quot;:&#123; // json类型 &quot;key4_1&quot; : 12, &quot;key4_2&quot; : &quot;kkk&quot; &#125;, &quot;key5&quot;:[&#123; // json数组 &quot;key5_1_1&quot; : 12, &quot;key5_1_2&quot; : &quot;abc&quot; &#125;, &#123; &quot;key5_2_1&quot; : 41, &quot;key5_2_2&quot; : &quot;bbj&quot; &#125;]&#125;;jsons.key1jsons.key3[1]jsons.key4.key4_2jsons.key5[1].key5_2_1 5.2 JSON对象的访问json对象，顾名思义，就知道它是一个对象。里面的key就是对象的属性。我们要访问一个对象的属性，只需要使用【对象名.属性名】的方式访问即可。 12345678910111213141516171819202122232425262728&lt;script type=&quot;text/javascript&quot;&gt; // json的定义 var jsons = &#123; &quot;key1&quot;:&quot;abc&quot;, // 字符串类型 &quot;key2&quot;:1234, // Number &quot;key3&quot;:[1234,&quot;21341&quot;,&quot;53&quot;], // 数组 &quot;key4&quot;:&#123; // json类型 &quot;key4_1&quot; : 12, &quot;key4_2&quot; : &quot;kkk&quot; &#125;, &quot;key5&quot;:[&#123; // json数组 &quot;key5_1_1&quot; : 12, &quot;key5_1_2&quot; : &quot;abc&quot; &#125;,&#123; &quot;key5_2_1&quot; : 41, &quot;key5_2_2&quot; : &quot;bbj&quot; &#125;] &#125;; // 访问json的属性 alert(jsons.key1); // &quot;abc&quot; // 访问json的数组属性 alert(jsons.key3[1]); // &quot;21341&quot; // 访问json的json属性 alert(jsons.key4.key4_1);//12 // 访问json的json数组 alert(jsons.key5[0].key5_1_2);//&quot;abc&quot;&lt;/script&gt; 5.3 JSON中两个常用的方法 JSON对象和字符串对象的互转： JSON.stringify( json )：此方法可以把一个json对象转换成为json字符串 JSON.parse( jsonString )： 此方法可以把一个json字符串转换成为json对象 代码示例 123456789101112131415&lt;script type=&quot;text/javascript&quot;&gt; // 一个json对象 var obj = &#123; &quot;a&quot; : 12, &quot;c&quot; : &quot;str&quot; &#125;; // 把json对象转换成为字符串对象 var objStr = JSON.stringify(obj); // alert(objStr); // 把json对象的字符串，转换成为 json对象 var jsonObj = JSON.parse(objStr); alert(jsonObj);&lt;/script&gt; 5.4 JSON在Java中的使用 我们要使用json和java中使用，我们需要使用到一个第三方的包。目前主流的解析JSON的工具大概有三种json-lib、jackson、gson。三种解析工具相比较json-lib的使用复杂，且效率较差。而Jackson和gson解析效率较高。使用简单，这里我们以gson为例讲解。 J g Gson是Google公司出品的解析JSON工具，使用简单，解析性能好。 Gson中解析JSON的核心是Gson的类，解析操作都是通过该类实例进行。 Gson 提供的用来在 Java 对象和 JSON 数据之间进行映射的 Java 类库，可以将一个 JSON 字符串转成一个 Java 对象，或者反过来。 json在java中的操作常见的有三种情况 java对象和json的转换 java对象list集合和json的转换 map对象和json的转换 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.atguigu.gson;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;import com.google.gson.Gson;import com.google.gson.reflect.TypeToken;public class GsonTest &#123; static class Person &#123; private int age; private String name; public Person() &#123; // TODO Auto-generated constructor stub &#125; public Person(int age, String name) &#123; this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Person [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;; &#125; &#125; // 要把复杂的json字符串转换成为java对象。需要继承TypeToken类。 // 并把返回的类型当成TypeToken的泛型注入 static class PersonType extends TypeToken&lt;List&lt;Person&gt;&gt; &#123; &#125; public static void main(String[] args) &#123; // json操作，一定要先new一个gson对象。 Gson gson = new Gson(); // java对象--json Person person = new Person(12, &quot;wzg168&quot;); // 把对象转成为json字符串 String personjson = gson.toJson(person); System.out.println(personjson); // 把json字符串转换成为java对象 Person p = gson.fromJson(personjson, Person.class); System.out.println(p); System.out.println(&quot;------------------------------------------&quot;); // 2、java对象list集合和json的转换 List&lt;Person&gt; list = new ArrayList&lt;Person&gt;(); for (int i = 0; i &lt; 3; i++) &#123; list.add(new Person(10 * i, &quot;name-&quot; + i)); &#125; String jsonListString = gson.toJson(list); System.out.println(jsonListString); // 把json数组转换成为List对象 // List&lt;Person&gt; ps = gson.fromJson(jsonListString, new PersonType().getType()); // 我们也可以使用匿名内部类 List&lt;Person&gt; ps = gson.fromJson(jsonListString, new TypeToken&lt;List&lt;Person&gt;&gt;() &#123; &#125;.getType()); System.out.println(ps); System.out.println(&quot;------------------------------------------&quot;); // 3、map对象和json的转换 Map&lt;String, Person&gt; mapPerson = new HashMap&lt;String, GsonTest.Person&gt;(); // 添加person到map中 mapPerson.put(&quot;p1&quot;, new Person(1, &quot;person-1&quot;)); mapPerson.put(&quot;p2&quot;, new Person(2, &quot;person-2&quot;)); // 把map转换成为json对象 String jsonMapString = gson.toJson(mapPerson); System.out.println(jsonMapString); // 通过使用匿名内部类的方式 Map&lt;String, Person&gt; map = gson.fromJson(jsonMapString, new TypeToken&lt;HashMap&lt;String, Person&gt;&gt;() &#123;&#125;.getType()); System.out.println(map); &#125;&#125;","categories":[],"tags":[]},{"title":"分布式RPC框架Apache Dubbo","slug":"分布式RPC框架Apache Dubbo","date":"2020-11-29T11:50:35.567Z","updated":"2020-11-29T15:21:45.730Z","comments":true,"path":"2020/11/29/分布式RPC框架Apache Dubbo/","link":"","permalink":"http://ilusymon.xyz/2020/11/29/%E5%88%86%E5%B8%83%E5%BC%8FRPC%E6%A1%86%E6%9E%B6Apache%20Dubbo/","excerpt":"Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和Spring框架无缝集成。 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。","text":"Dubbo是阿里巴巴公司开源的一个高性能优秀的服务框架，使得应用可通过高性能的 RPC 实现服务的输出和输入功能，可以和Spring框架无缝集成。 Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 1. 软件架构的演进过程软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。 1.1 单体架构 一个归档包（例如war格式或者Jar格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构，这是一种比较传统的架构风格。。 架构说明： 全部功能集中在一个项目内（All in one）。 架构优点： 架构简单，前期开发成本低、开发周期短，适合小型项目。 架构缺点： ① 复杂性高 整个项目包含的模块非常多，模块的边界模糊，依赖关系不清晰，代码质量参差不齐,整个项目非常复杂。每次修改代码都心惊胆战，甚至添加一个简单的功能，或者修改一个BUG都会造成隐含的缺陷。 ② 技术债务逐渐上升 随着时间推移、需求变更和人员更迭，会逐渐形成应用程序的技术债务，并且越积越多。已使用的系统设计或代码难以修改，因为应用程序的其他模块可能会以意料之外的方式使用它。 ③ 部署速度逐渐变慢 随着代码的增加，构建和部署的时间也会增加。而在单体应用中，每次功能的变更或缺陷的修复都会导致我们需要重新部署整个应用。全量部署的方式耗时长、影响范围大、风险高，这使得单体应用项目上线部署的频率较低，从而又导致两次发布之间会有大量功能变更和缺陷修复，出错概率较高。 ④ 扩展能力受限，无法按需伸缩 单体应用只能作为一个整体进行扩展，无法结合业务模块的特点进行伸缩。 ⑤ 阻碍技术创新 单体应用往往使用统一的技术平台或方案解决所有问题，团队的每个成员都必须使用相同的开发语言和架构，想要引入新的框架或技术平台非常困难。 总结： 全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。 技术栈受限，只能使用一种语言开发。 系统性能扩展只能通过扩展集群节点，成本高。 项目目录结构 1.2 垂直架构 架构说明： 按照业务进行切割，形成小的单体项目。 垂直MVC项目主要有表现层，业务逻辑层，数据访问层组成的MVC架构，整个项目打包放在一个tomcat里面。适合于 访问量小，用户数不多的业务。 架构优点： 技术栈可扩展（不同的系统可以用不同的编程语言编写）。 架构缺点： ① 这是一个大而全的项目，项目的部署效率很低，代码全量编译和部署一次发布需要很长时间，更重要的是 如果某个功能出错有问题，所有的功能都需要再重新打包编译，部署效率极低。 ② 团队协作难度高，如多人使用 git 很可能在同一个功能上，多人同时进行了修改，作为一个大而全的项目，可能个人只是需要开发其中一个小的模块的需求，却需要导入整个项目全量的代码。 总结： 功能集中在一个项目中，不利于开发、扩展、维护。 系统扩张只能通过集群的方式。 项目之间功能冗余、数据冗余、耦合性强。 项目目录结构 1.3 SOA架构SOA 全称为 Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。 站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。 架构说明： 将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。 ESB 简单 来说 ESB 就是一根管道，用来连接各个服务节点。为了集 成不同系统，不同协议的服务，ESB 做了消息的转化解释和路由工作，让不同的服务互联互通； 架构优点： 重复功能或模块抽取为服务，提高开发效率。 可重用性高。 可维护性高。 架构缺点： 各系统之间业务不同，很难确认功能或模块是重复的。 抽取服务的粒度大。 系统和服务之间耦合度高。 从单体应用到SOA架构的转变： 1.4 微服务架构 微服务架构: 其实和 SOA 架构类似,微服务是在 SOA 上做的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用。这些小应用之间通过服务完成交互和集成。 架构说明： 将系统服务层完全独立出来，抽取为一个一个的微服务。 抽取的粒度更细，遵循单一原则。 采用轻量级框架协议传输。 API 服务网关 API网关是一个服务器，是系统的唯一入口。从面向对象设计的角度看，它与外观模式类似。API网关封装了系统内部架构，为每个客户端提供一个定制的API。它可能还具有其它职责，如身份验证、监控、负载均衡、缓存、请求分片与管理、静态响应处理。API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能。通常，网关也是提供REST/HTTP的访问API。服务端通过API-GW注册和管理服务。 架构优点： 服务拆分粒度更细，有利于提高开发效率。 可以针对不同服务制定对应的优化方案。 适用于互联网时代，产品迭代周期更短。 架构缺点： 粒度太细导致服务太多，维护成本高。 分布式系统开发的技术成本高，对团队的挑战大。 2. Apache Dubbo概述2.1 Dubbo简介 Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。 什么是RPC？ RPC全称为remote procedure call，即远程过程调用。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。 需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo等。 Dubbo官网地址：http://dubbo.apache.org Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 通俗一点说，就是一般程序员对于本地的过程调用很熟悉，那么我们把 RPC 作成和本地调用完全类似，那么就更容易被接受，使用起来毫无障碍。 2.2 Dubbo架构 Dubbo架构图（Dubbo官方提供）如下： 节点角色说明： 节点 角色名称 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 虚线都是异步访问，实线都是同步访问 蓝色虚线:在启动时完成的功能 红色虚线(实线)都是程序运行过程中执行的功能 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3. 服务注册中心Zookeeper通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。 3.1 Zookeeper介绍Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。 为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统(也是一个树型目录结构)： 我的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建文件，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径 Zookeeper树型目录服务： 流程说明： 服务提供者(Provider)启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者(Consumer)启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心(Monitor)启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址 3.2 安装Zookeeper下载地址：http://archive.apache.org/dist/zookeeper/ 3.3 启动、停止Zookeeper 需要注意： Zookeeper在Windows下启动只需要运行zkServer.cmd双击即可（需保证运行环境中正确安装了Java运行环境） 但是在有的时候会出现双击闪退的情况。针对闪退，可按照一下步骤进行解决： 1 、编辑zkServer.cmd文件末尾添加pause 。这样运行出错就不会退出，会提示错误信息，方便找到原因。例如原因如下： 2、重新双击运行zkServer.cmd 错误原因 ，找不到zoo.cfg配置文件 3、编辑zkEnv.cmd 4 、修改如下： 5、重新双击zkServer.cmd启动 6 zoo_sample.cfg配置文件介绍 123456&#x2F;&#x2F; 数据存储目录，修改数据存储目录 ..&#x2F;data 复制的时候注意，小心空格dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper &#x2F;&#x2F;默认配置文件，修改路径如下dataDir&#x3D;..&#x2F;data &#x2F;&#x2F; 端口clientPort&#x3D;2181 4. Dubbo快速入门Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。 4.1 服务提供方开发开发步骤： （1）创建maven工程（打包方式为war）provider，在pom.xml文件中导入如下坐标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.12.1.GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8081&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; （2）配置web.xml文件 创建 webapp/WEB-INF/web.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; （3）创建服务接口 12345package com.dubbo.service;public interface HelloService &#123; String sayHello(String name);&#125; （4）创建服务实现类 123456789101112131415161718package com.maweiqi.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.maweiqi.service.HelloService;/** * HelloServiceImpl * * @Author: 马 伟 奇 * @Description: */@Servicepublic class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;hello &quot; + name; &#125;&#125; 注意：服务实现类上使用的 Service 注解是Dubbo提供的，用于对外发布服务 （5）在src/main/resources下创建 applicationContext-service.xml 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name=&quot;dubbodemo_provider&quot; /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt; &lt;!-- 注册 协议和port 端口默认是20880 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20881&quot;/&gt; &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务 --&gt; &lt;dubbo:annotation package=&quot;com.dubbo.service.impl&quot; /&gt;&lt;/beans&gt; （6）启动服务 或者： 4.2 服务消费方开发开发步骤： （1）创建 maven 工程（打包方式为war）consumer，pom.xml 配置和上面服务提供者相同，只需要将 Tomcat 插件的端口号改为8082即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.12.1.GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8082&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; （2）配置web.xml文件 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; （3）将服务提供者工程中的HelloService接口复制到当前工程 12345package com.dubbo.service;public interface HelloService &#123; String sayHello(String name);&#125; （4）编写Controller 123456789101112131415161718192021222324252627282930package com.dubbo.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.dubbo.service.HelloService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * @author Symon * @version 1.0 * @className HelloController * @description TODO * @date 2020/11/19 15:50 */@Controller@RequestMapping(&quot;/demo&quot;)public class HelloController &#123; @Reference private HelloService helloService; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125; 注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解 （5）在src/main/resources下创建applicationContext-web.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name=&quot;dubbodemo-consumer&quot; /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt; &lt;!-- 扫描的方式暴露接口 --&gt; &lt;dubbo:annotation package=&quot;com.dubbo.controller&quot;/&gt; &lt;!-- 运行dubbo不检查提供者是否提前开启 --&gt; &lt;dubbo:consumer check=&quot;false&quot;/&gt;&lt;/beans&gt; （6）运行测试 在浏览器输入http://localhost:8082/demo/hello?name=Jack，查看浏览器输出结果 思考一：上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？ 答：这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。 思考二：在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？ 答：Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。 思考三：上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？ 答：Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。 4.3 代码重构① 创建项目：dubbodemo_interface ② 把 项目dubbodemo_consumer 和 项目dubbodemo_provider当中的 接口 HelloService 拷贝到dubbodemo_interface工程里面 ③ 删除工程dubbodemo_consumer 和 工程dubbodemo_provider当中的 接口 HelloService consumer 工程和provider添加pom文件的依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.dubbo&lt;/groupId&gt; &lt;artifactId&gt;interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; ④ 运行程序：http://localhost:8084/demo/hello?name=haha 4.4 加入log4j日志 运行程序发现dubbo建议大家使用 log4j日志，我们就需要在 resources 文件夹下面引入log4j.properties日志文件 123456789101112131415### direct log messages to stdout ###log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target&#x3D;System.errlog4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### direct messages to file mylog.log ###log4j.appender.file&#x3D;org.apache.log4j.FileAppenderlog4j.appender.file.File&#x3D;c:\\\\mylog.loglog4j.appender.file.layout&#x3D;org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n### set log levels - for more verbose logging change &#39;info&#39; to &#39;debug&#39; ###log4j.rootLogger&#x3D;debug, stdout 5. Dubbo管理控制台我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 5.1 安装安装步骤： （1）将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下 （2）启动tomcat，此war文件会自动解压 （3）修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号 123dubbo.registry.address&#x3D;zookeeper:&#x2F;&#x2F;192.168.134.129:2181dubbo.admin.root.password&#x3D;rootdubbo.admin.guest.password&#x3D;guest （4）重启tomcat 5.2 使用操作步骤： （1）访问http://localhost:8080/dubbo-admin-2.6.0/，输入用户名(root)和密码(root) （2）启动服务提供者工程和服务消费者工程，可以在查看到对应的信息 6.Dubbo相关配置说明6.1 包扫描1&lt;dubbo:annotation package&#x3D;&quot;com.dubbo.service&quot; &#x2F;&gt; 服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。 如果不使用包扫描，也可以通过如下配置的方式来发布服务： 12&lt;bean id&#x3D;&quot;helloService&quot; class&#x3D;&quot;com.dubbo.service.impl.HelloServiceImpl&quot; &#x2F;&gt;&lt;dubbo:service interface&#x3D;&quot;com.dubbo.api.HelloService&quot; ref&#x3D;&quot;helloService&quot; &#x2F;&gt; 作为服务消费者，可以通过如下配置来引用服务： 12&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;&lt;dubbo:reference id&#x3D;&quot;helloService&quot; interface&#x3D;&quot;com.dubbo.api.HelloService&quot; &#x2F;&gt; 上面这种方式发布和引用服务，一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。 6.2 协议1&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; port&#x3D;&quot;20880&quot;&#x2F;&gt; 一般在服务提供者一方配置，可以指定使用的协议名称和端口号。 其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。 推荐使用的是dubbo协议。 dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。 也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如： 1234567&lt;!-- 多协议配置 --&gt;&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;&lt;dubbo:protocol name=&quot;rmi&quot; port=&quot;1099&quot; /&gt;&lt;!-- 使用dubbo协议暴露服务 --&gt;&lt;dubbo:service interface=&quot;com.dubbo.api.HelloService&quot; ref=&quot;helloService&quot; protocol=&quot;dubbo&quot; /&gt;&lt;!-- 使用rmi协议暴露服务 --&gt;&lt;dubbo:service interface=&quot;com.dubbo.api.DemoService&quot; ref=&quot;demoService&quot; protocol=&quot;rmi&quot; /&gt; 6.3 启动时检查1&lt;dubbo:consumer check&#x3D;&quot;false&quot;&#x2F;&gt; 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。 建议在开发阶段将check值设置为false，在生产环境下改为true。 6.4 负载均衡负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。 在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。 配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 123456789101112131415161718192021222324@Controller@RequestMapping(&quot;/demo&quot;)public class HelloController &#123; //在服务消费者一方配置负载均衡策略 @Reference(check = false,loadbalance = &quot;random&quot;) private HelloService helloService; @RequestMapping(&quot;/hello&quot;) @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125;//在服务提供者一方配置负载均衡@Service(loadbalance = &quot;random&quot;)public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return &quot;hello &quot; + name; &#125;&#125; 可以通过启动多个服务提供者来观察Dubbo负载均衡效果。 注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。 在实际生产环境中，多个服务提供者是分别部署在不同的机器上，所以不存在端口冲突问题。 6.4.1 修改 provider① 修改pom文件的端口号，防止端口冲突 ② 修改 applicationContext-service.xml 配置文件 ③ 为了演示方便，修改打印端口 ④ 运行 provider 提供者两次，分别都修改端口 ⑤ 运行消费者 consumer ⑥ 请求 http://localhost:8082/demo/hello?name=Jack 7. 解决Dubbo无法发布被事务代理的Service问题前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。 但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。 7.1 问题展示在入门案例的服务提供者dubbodemo_provider工程基础上进行展示 操作步骤： （1）在pom.xml文件中增加maven坐标 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; （2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name=&quot;dubbodemo_provider&quot; /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot;/&gt; &lt;!-- 注册 协议和port 端口默认是20880 --&gt; &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20882&quot;&gt;&lt;/dubbo:protocol&gt; &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务 --&gt; &lt;dubbo:annotation package=&quot;com.maweiqi.service.impl&quot; /&gt; &lt;!--数据源--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test&quot; /&gt; &lt;/bean&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--开启事务控制的注解支持--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; &lt;/beans&gt; 上面连接的数据库可以自行创建 （3）在HelloServiceImpl类上加入@Transactional注解 1234567891011121314package com.maweiqi.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.maweiqi.service.HelloService;import org.springframework.transaction.annotation.Transactional;@Service@Transactionalpublic class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;8086 hello &quot; + name; &#125;&#125; （4）启动服务提供者和服务消费者，并访问 上面的错误为没有可用的服务提供者 查看dubbo管理控制台发现服务并没有发布，如下： 可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处理 7.2 解决方案通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.maweiqi.service），所以后面真正发布服务的代码没有执行。 解决方式操作步骤： （1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象,添加如下配置： 12&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; proxy-target-class=&quot;true&quot;/&gt; （2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型 1234567891011121314package com.maweiqi.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.maweiqi.service.HelloService;import org.springframework.transaction.annotation.Transactional;@Service(interfaceClass = HelloService.class)@Transactionalpublic class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return &quot;8086 hello &quot; + name; &#125;&#125; 此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口，如下：","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-11-29T09:21:11.840Z","updated":"2020-11-29T15:22:36.403Z","comments":true,"path":"2020/11/29/hello-world/","link":"","permalink":"http://ilusymon.xyz/2020/11/29/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"容器","slug":"容器","permalink":"http://ilusymon.xyz/tags/%E5%AE%B9%E5%99%A8/"}]}